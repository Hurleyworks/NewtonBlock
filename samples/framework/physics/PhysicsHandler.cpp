// This source file was auto-generated by ClassMate++
// Created: 5 Nov 2015 7:19:39 am
// Copyright (c) 2015, HurleyWorks

#include <string>
#include "PhysicsHandler.h"
#include "SpaceTime.h"

int64_t PhysicsHandler::totalMemoryUsed = 0;

using namespace ci;

// ctor
PhysicsHandler::PhysicsHandler()
{
}

// dtor
PhysicsHandler::~PhysicsHandler ()
{	
	if (world)
	{
		NewtonDestroy(world);
		world = nullptr;
		CI_ASSERT(totalMemoryUsed == 0);
	}
}

void PhysicsHandler::init()
{
	NewtonSetMemorySystem(PhysicsHandler::physicsAlloc, PhysicsHandler::physicsFree);

	world = NewtonCreate();
	if (!world)
	{
		CI_ASSERT(false);
		throw std::runtime_error("Could not create Newton World");
	}

	NewtonWorldSetUserData(world, this);
	NewtonSetSolverModel(world, 1);
	NewtonSetFrictionModel(world, 0);
	NewtonInvalidateCache(world);
	NewtonSetThreadsCount(world, std::thread::hardware_concurrency());

	physicsScene = PhysicsScene::create(world);
	physicsEngine = PhysicsEngine::create(world);
}

PhysicsBodyRef PhysicsHandler::addBody(const ci::TriMeshRef & triMesh, const BodyDesc & bodyDesc, const SpaceTime & st, bool isInstance)
{
	PhysicsBodyRef pBody = physicsScene->createPhysicsBody();
	pBody->triMesh = triMesh;
	pBody->desc = bodyDesc;
	pBody->st = st;

	if (isInstance)
		pBody->state.getState() |= PBodyState::Instance;

	// async call to process body in the physics engine
	dispatcher.call(&ActiveDispatcher::dispatchBody, pBody, physicsScene, physicsEngine->getEngineState());

	return pBody;
}

bool PhysicsHandler::runSimulation()
{
	// bodies are added to the scene asynchronously 
	// make sure they are all ready, except  projectiles
	for (auto & body : physicsScene->getBodies())
	{
		if (!body) continue;
		if (body->desc.name == DEFAULT_BODY_NAME) continue;

		if (!body->state.isReady()) return false;
	}

	physicsEngine->setEngineState(EngineState::Running);

	return true;
}

void PhysicsHandler::removeBody(PhysicsBodyRef & pBody)
{
	if (!pBody) return;
	if (pBody->state.isDeleted()) return;

	pBody->state.getState() |= PBodyState::Deleted;

	// reset body to default state
	pBody->desc.setToDefault();
	pBody->st.reset();
	pBody->triMesh = nullptr;

	// add to recycle bin
	physicsScene->addToRecycle(pBody);

	// remove from engine asynchronously
	dispatcher.call(&ActiveDispatcher::dispatchBody, pBody, physicsScene, physicsEngine->getEngineState());
}

void PhysicsHandler::resetSimulation()
{
	// delete any projectiles since resetting
	// them does not make sense
	for (auto & body : physicsScene->getBodies())
	{
		if (body->desc.name == DEFAULT_PROJECTILE_NAME)
			removeBody(body);
	}

	physicsScene->reset();

	// Don't set the Engine state to Reset until "after"
	// the deleted projectiles have been sent to the engine
	// for processing to ensure they are deleted on Newton's thread
	physicsEngine->setEngineState(EngineState::Reset);
}

// physicsAlloc
void * PhysicsHandler::physicsAlloc(int sizeInBytes)
{
	totalMemoryUsed += sizeInBytes;
	return new char[sizeInBytes];
}

// physicsFree
void PhysicsHandler::physicsFree(void * ptr, int sizeInBytes)
{
	totalMemoryUsed -= sizeInBytes;
	delete[](char*)ptr;
}
