// This source file was auto-generated by ClassMate++
// Created: 5 Nov 2015 10:20:56 am
// Copyright (c) 2015, HurleyWorks

#include "BodyHandler.h"

using namespace ci;

// ctor
BodyHandler::BodyHandler (NewtonWorld * const world)
	: ops(world)
{	
}

void BodyHandler::processPhysicsBody(PhysicsBodyRef & pBody, EngineState engineState)
{
 	if (!pBody) return;

	// bodies created on the engine thread while the engine is running
	// must also be destroyed on the engine thread
	if (engineState == EngineState::Running || pBody->state.isCreatedOnEngineThread())
	{
		// has been deleted 
		if (pBody->state.isDeleted())
		{
			pendingRemoves_.push(pBody);
			return;
		}

		// not in the engine yet and not in the recycled bin
		if (!pBody->state.isInEngine() && !pBody->state.isRecycled())
		{
			pendingAdds.push(pBody);
			return;
		}
	}
	else
	{
		// has been deleted 
		if (pBody->state.isDeleted())
		{
			processBodyRemoval(pBody);
			return;
		}

		// not in the engine yet and not in the recycled bin
		if (!pBody->state.isInEngine() && !pBody->state.isRecycled())
		{
			processNewBody(pBody);
			return;
		}
	}
}

void BodyHandler::setBodyPose(PhysicsBodyRef & pBody)
{
	if (!pBody) return;
	if (!pBody->state.isReady()) return;

	const NewtonBody * const newtonBody = (NewtonBody*)pBody->userData;
	if (!newtonBody) return;

	dMatrix pose;
	if (!ops.glmToNewton(pBody->st.worldTransform, pose))
	{
		throw std::runtime_error("Invalid pose");
	}

	// automatically set scale too while we're at it
	const vec3 & s = pBody->st.scale;
	NewtonBodySetCollisionScale(newtonBody, s[0], s[1], s[2]);
	NewtonBodySetMatrix(newtonBody, &pose[0][0]);
}

void BodyHandler::resetPhysicsProperties(PhysicsBodyRef & pBody)
{
	if (!pBody) return;
	if (!pBody->state.isReady()) return;

	NewtonBody * const newtonBody = (NewtonBody*)pBody->userData;
	if (!newtonBody) return;

	// reset newton body linear and rotational velocities
	dVector value = dVector(0.0f, 0.0f, 0.0f);
	NewtonBodySetVelocity(newtonBody, &value[0]);
	NewtonBodySetOmega(newtonBody, &value[0]);

	// reset force
	dVector gravityForce;
	for (int i = 0; i < 3; i++)
		gravityForce[i] = pBody->desc.mass * pBody->desc.force[i];

	NewtonBodySetForce(newtonBody, &gravityForce[0]);
}

void BodyHandler::onPostPhysicsUpdate(void * const userData, bool abort, float timeStep)
{
	// Thsi call comes on Newton's thread

	if (abort) return;

	while (!pendingAdds.empty())
	{
		PhysicsBodyRef newBody = nullptr;
		pendingAdds.pop(newBody);
		if (newBody)
		{
			// bodies created on the engine thread must be flagged so they 
			// can be destroyed on the same thread
			newBody->state.getState() |= PBodyState::CreatedOnEngineThread;
			processNewBody(newBody);
		}
	}

	while (!pendingRemoves_.empty())
	{
		PhysicsBodyRef bodyToDelete = nullptr;
		pendingRemoves_.pop(bodyToDelete);
		if (bodyToDelete)
		{
			processBodyRemoval(bodyToDelete);
		}
	}
}

void BodyHandler::processNewBody(PhysicsBodyRef & pBody)
{
	// extract the starting pose
	dMatrix startPose;
	if (!ops.glmToNewton(pBody->st.worldTransform, startPose))
	{
		throw std::runtime_error("Found invalid matrix!");
	}

	switch (pBody->desc.flex)
	{
		case FlexType::Rigid:
		{
			NewtonCollision * const collision = ops.createCollisionShape(pBody);
			if (!collision)
			{
				throw std::runtime_error("Could not create a NewtonCollison!");
			}

			NewtonBody * const newtonBody = ops.createRigidBody(pBody, startPose, collision);
			if (!newtonBody)
			{
				NewtonDestroyCollision(collision);
				throw std::runtime_error("Could not create a NewtonBody!");
			}

			// don't touch the collision object if we're an instance!!!!
			if (!pBody->state.isInstance())
			{
				NewtonCollisionSetUserData(collision, pBody.get());
				NewtonDestroyCollision(collision);
			}
			

			// lower the being processed flag
			if (pBody->state.isBeingProcessed())
				pBody->state.getState() ^= PBodyState::BeingProcessed;

			// we're officially in the engine
			pBody->state.getState() |= PBodyState::InEngine;
		}

		default:
			break;
	}
}

void BodyHandler::processBodyRemoval(PhysicsBodyRef & pBody)
{
	if (!pBody->state.isInEngine() || !pBody->userData) return;

	const NewtonBody * const newtonBody = (NewtonBody*)pBody->userData;
	NewtonDestroyBody(newtonBody);

	pBody->userData = nullptr;

	if (pBody->state.isCreatedOnEngineThread())
		pBody->state.getState() ^= PBodyState::CreatedOnEngineThread;

	// we're not in the engine
	pBody->state.getState() ^= PBodyState::InEngine;

	// we're not longer deleted
	pBody->state.getState() ^= PBodyState::Deleted;

	// we're officially reycled
	pBody->state.getState() |= PBodyState::Recycled;

}

